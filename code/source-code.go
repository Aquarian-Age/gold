package code

import (
	"bytes"
	"fmt"
	"go/ast"
	"io/ioutil"
	"log"
	"path/filepath"
	"strings"
	"time"

	"go101.org/gold/util"
)

//type SourceFile struct {
//	Path    string
//	Pkg     *Package
//	AstFile *ast.File // non-nil for compiled Go files
//}

func (d *CodeAnalyzer) CollectSourceFiles(onSubTaskDone func(int, time.Duration, ...int32)) {
	var stopWatch = util.NewStopWatch()

	var logProgress = func(task int, args ...int32) {
		onSubTaskDone(task, stopWatch.Duration(), args...)
	}

	defer func() {
		logProgress(SubTask_CollectSourceFiles)
	}()

	//log.Println("=================== CollectSourceFiles")

	//d.sourceFile2PackageTable = make(map[string]SourceFile, len(d.packageList)*5)
	d.sourceFile2PackageTable = make(map[string]*Package, len(d.packageList)*5)
	d.generatedFile2OriginalFileTable = make(map[string]string, 128)
	//d.sourceFileLineOffsetTable = make(map[string]int32, 256)
	for _, pkg := range d.packageList {
		//log.Println("====== ", pkg.Path())
		//if pkg.Path() == "unsafe" {
		//	//log.Println("///============== ", pkg.PPkg.GoFiles)
		//	//ast.Print(pkg.PPkg.Fset, pkg.PPkg.Syntax[0])
		//
		//	// For unsafe package, pkg.PPkg.CompiledGoFiles is blank.
		//	// ToDo: fill it in fillUnsafePackage? (Done)
		//
		//	path := pkg.PPkg.GoFiles[0]
		//
		//	d.sourceFile2PackageTable[path] = SourceFile{
		//		Path:    path,
		//		Pkg:     pkg,
		//		AstFile: pkg.PPkg.Syntax[0],
		//	}
		//
		//	continue
		//}

		if len(pkg.PPkg.CompiledGoFiles) != len(pkg.PPkg.Syntax) {
			panic(fmt.Sprintf("!!! len(pkg.PPkg.CompiledGoFiles) != len(pkg.PPkg.Syntax), %d:%d, %s", len(pkg.PPkg.CompiledGoFiles), len(pkg.PPkg.Syntax), pkg.Path()))
		}

		for _, path := range pkg.PPkg.OtherFiles {
			d.sourceFile2PackageTable[path] = pkg
			d.stats.Files++
		}

		for _, path := range pkg.PPkg.CompiledGoFiles {
			d.sourceFile2PackageTable[path] = pkg
		}

		for _, path := range pkg.PPkg.GoFiles {
			if _, ok := d.sourceFile2PackageTable[path]; !ok {
				//log.Println("! in GoFiles but not CompiledGoFiles:", path)
				d.sourceFile2PackageTable[path] = pkg
			}
			d.stats.Files++
		}

		d.BuildCgoFileMappings(pkg)

		//d.stats.Files += int32(len(pkg.SourceFiles))
	}
}

//==================================

type SourceFileInfo struct {
	// Filename only.
	BareFilename          string
	BareGeneratedFilename string

	// One and only one of the following two is not blank.
	//NonGoFile      string
	//OriginalGoFile string

	// The full path of a (Go or others) source file.
	// It might be blank for some cgo generated files.
	OriginalFile string

	// The followings are blank for most files.
	GeneratedFile string
	//GoFileContentOffset int32
	//GoFileLineOffset    int32

	// Non-nil for Go files.
	// If an original Go file has a corresponding generated file,
	// then the ast file is for that generated file.
	AstFile *ast.File
}

var cgoGenIdent = []byte(`// Code generated by cmd/cgo; DO NOT EDIT.`)
var reposIdent = []byte(`//line `)

// https://github.com/golang/go/issues/24183
// https://github.com/golang/go/issues/26207
// https://github.com/golang/go/issues/36072
// The fucntion is not robust enough to handle all kinds of special cases.
// 1. It doesn't consider /*line file:m:n*/ form.
// 2. It doesn't handle multiple "//line ..." occurences.
// 3. It should ignore the general content enclosed in other comments.
//    /*
//    //line file:m:n
//    */
// Maybe it is best to check the comments nodes in the already provided ast.File.
func cgoFileInfo(filename string, astFile *ast.File) *SourceFileInfo {
	fileContent, err := ioutil.ReadFile(filename)
	if err != nil {
		log.Println("cgoFileInfo ReadFile error:", err)
		return nil
	}

	// ToDo: the current implement strongly depends on the cgo file genenration implementation.
	//       Here it is assumed that the "// Code generated by cmd/cgo; DO NOT EDIT." is the 4th line.
	if !bytes.HasPrefix(fileContent, cgoGenIdent) {
		return &SourceFileInfo{
			BareGeneratedFilename: filepath.Base(filename),
			OriginalFile:          "",
			GeneratedFile:         filename,
			AstFile:               astFile,
		}
	}

	for lineOffset, data := 1, fileContent; len(data) > 0; lineOffset++ {
		i := bytes.IndexByte(data, '\n')
		k := i
		if k < 0 {
			k = len(data)
		}
		if k > 0 && data[k-1] == '\r' {
			k--
		}
		for bytes.HasPrefix(data[:k], reposIdent) {
			line := bytes.TrimSpace(data[len(reposIdent):k])
			indexB := bytes.LastIndexByte(line, ':')
			if indexB < 0 {
				break
			}

			// Assume the colume offset is 1.
			var goFilename string
			if indexA := bytes.LastIndexByte(line[:indexB], ':'); indexA >= 0 {
				goFilename = string(line[:indexA])
			} else {
				goFilename = string(line[:indexB])
			}

			return &SourceFileInfo{
				BareFilename:  filepath.Base(goFilename),
				OriginalFile:  goFilename,
				GeneratedFile: filename,
				AstFile:       astFile,
				//: int32(len(fileContent) - len(data[i+1:])),
				//GoFileLineOffset:    int32(lineOffset),
			}
		}
		if i >= 0 {
			data = data[i+1:]
		}
	}

	return nil
}

func (d *CodeAnalyzer) BuildCgoFileMappings(pkg *Package) {
	if pkg.SourceFiles != nil {
		return
	}

	pkg.SourceFiles = make([]SourceFileInfo, 0, len(pkg.PPkg.CompiledGoFiles))

	for i, compiledFile := range pkg.PPkg.CompiledGoFiles {
		if strings.HasSuffix(compiledFile, ".go") {
			// ToDo: verify compiledFile must be also in  pkg.PPkg.GoFiles
			pkg.SourceFiles = append(pkg.SourceFiles,
				SourceFileInfo{
					BareFilename:  filepath.Base(compiledFile),
					OriginalFile:  compiledFile,
					GeneratedFile: compiledFile,
					AstFile:       pkg.PPkg.Syntax[i],
				},
			)
			continue
		}
		info := cgoFileInfo(compiledFile, pkg.PPkg.Syntax[i])
		if info == nil {
			log.Println(compiledFile, "!has no original file:", compiledFile)
			continue
		}

		if info.OriginalFile != "" && info.GeneratedFile != info.OriginalFile {
			d.generatedFile2OriginalFileTable[info.GeneratedFile] = info.OriginalFile
		}

		//info.AstFile = pkg.PPkg.Syntax[i]
		pkg.SourceFiles = append(pkg.SourceFiles, *info)

		//if info.GoFileLineOffset != 0 {
		//	d.sourceFileLineOffsetTable[info.OriginalGoFile] = info.GoFileLineOffset
		//}
	}

	//for i := range pkg.SourceFiles {
	//	info := &pkg.SourceFiles[i]
	//	log.Println("===", info.OriginalGoFile)
	//	log.Println("   ", info.GeneratedFile, info.GoFileContentOffset)
	//}

	for _, path := range pkg.PPkg.OtherFiles {
		pkg.SourceFiles = append(pkg.SourceFiles,
			SourceFileInfo{
				BareFilename: filepath.Base(path),
				OriginalFile: path,
			},
		)
	}
}
